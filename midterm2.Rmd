---
title: "Sta 523 - Midterm 2 - Spring 2016"
output: rmarkdown::html_document
runtime: shiny
---

<br/><br/>

### Rules

1. Your solutions must be written up using this R Markdown (Rmd) file, this file must include your code and write up for each task.

2. This exam is open book, open internet, closed other people. You may use *any* online or book based resource you would like, but you must include citations for any code that you use (directly or indirectly). You *may not* consult with anyone else about this exam other than the Professor or TAs for this course - this includes posting anything online.

3. You have until 11:59 pm on Monday, December 5th to complete this exam and turn it in via your personal Github repo - late work will not be accepted. Technical difficulties are not an excuse for late work - do not wait until the last minute to commit / push.

4. All of your answers must include a brief description / writeup of your approach. This includes both annotating / commenting your code *and* a separate written descriptions of all code / implementations. I should be able to suppress *all* code output in your document and still be able to read and make sense of your answers.

5. You may use any packages you want other than the `darksky` package.

6. The most important goal is to write code that can accomplish the given tasks, note however that grading will be partially based on the quality of the code you write - elegant, efficient code will be rewarded and messy, slow code will be penalized.

<br/>
<br/><br/>


### Shiny Weather

Dark Sky is an iOS and a website that provides "hyperlocal" weather forecasts. They make their data available to third parties via a web API which we will be using to create a simple shiny app. 

In order to access this API you need an account - if you go to https://darksky.net/dev/ you can sign up for an API account. Once you have registered you will have access to a usage console that includes a unique secret key (the long alphanumeric string at the bottom of the page) you will use to access the API. You can make up to 1000 API requests per day without incurring any cost, so there is no need to enter any billing information.

Documentation for the Dark Sky API can be found [here](https://darksky.net/dev/docs) and includes all information about how to create a properly formated API request and the details of the JSON format of the returned data.


#### Task 1 - Getting data from Dark Sky (30 pts)

Your first task is to write a single function that accepts an API key, latitude, longitude, and optionally a date and returns a data frame containing the hourly forecast for the given location (and time). The Dark Sky forecast API provides a number of different weather related predictions - all of these quantities should be returned by your function along with a properly formated datetime column. You do not need to return any of the currently, minutely, daily or other data. Note that you can exclude some of these results via your API request.

Some additional requirements:

* If no date is provided the results should be the hourly forecast for the next two days, this is the default behavior of a [Forecast Request](https://darksky.net/dev/docs/forecast).

* If a date is provided then hourly forecast data for the two days *prior* and two days *following* that date should be returned - this can be achieved via a [Time Machine Request](https://darksky.net/dev/docs/time-machine). 


<hr/>

<!-- Include your write up here and or below -->

```{r}
# load library
library(rvest)
library(dplyr)
library(stringr)
library(rjson)
library(jsonlite)
library(Rcpp)
library(anytime)
library(ggplot2)
library(shiny)
library(ggmap)
```


```{r}
# date = "2016-11-03"
# key = "3fb318b0ba046bde99d853585774584e"
get_darksky = function(key, lat, long, date = NULL){

  if(is.null(date)){
    lat = 36.0256090
    long = -78.9853810
    url =paste0("https://api.darksky.net/forecast/",key,"/" ,lat,",",long)
  }
  else{
    url = NULL
    date = paste(date, "12:00:00 EDT")
    date = paste(date(date) -3, "12:00:00 EDT")
    for (i in 1:5){
      newdate = paste(date(date) + i, "12:00:00 EDT")
      url1 = paste0("https://api.darksky.net/forecast/",key,"/",lat,",",long,",",as.numeric(as.POSIXlt(newdate)))
    url = c(url,url1)
    }
  }
# j1 = fromJSON(url[1])
# h1 = as.data.frame(j1$hourly$data)
# h1$time = anytime(as.numeric(h1$time))
# j2 = fromJSON(url[2])
# h2 = as.data.frame(j2$hourly$data)
# h2$time = anytime(as.numeric(h2$time))
# j3 = fromJSON(url[3])
# h3 = as.data.frame(j3$hourly$data)
# h3$time = anytime(as.numeric(h3$time))
# j4 = fromJSON(url[4])
# h4 = as.data.frame(j4$hourly$data)
# h4$time = anytime(as.numeric(h4$time))
# m1 = merge(h1,h4, all = TRUE)

  for(i in seq_along(url)){
    if(i == 1){
    json = fromJSON(url[i])
    hourlydate = as.data.frame(json$hourly$data)
    hourlydate$time = anytime(as.numeric(hourlydate$time))
    data = hourlydate
    }
    else{
    json = fromJSON(url[i])
    hourlydate = as.data.frame(json$hourly$data)
    hourlydate$time = anytime(as.numeric(hourlydate$time))
    data = merge(data, hourlydate,all = TRUE)
    }
  }
return(data)
}
```


<br/>



#### Task 2 - Prediction Locations (30 pts)

Your second task is to scrap US city location information from the following Wikipedia page: https://en.wikipedia.org/wiki/List_of_United_States_cities_by_population. The entire table should be read into R via web scraping (think `rvest`).

Your final data frame should meet the following requirements

* Rows should be filtered to only contains cities with more than 500,000 residents during the 2010 Census

* City and state names should be cleaned up 

* Location should be split up into new numeric latitude and longitude columns. Note that western longitudes and southern latitudes should be negative.


<hr/>

<!-- Include your write up here and or below -->

```{r}
url = paste0("https://en.wikipedia.org/wiki/List_of_United_States_cities_by_population")
page = read_html(url)

table = page %>%
  html_nodes(xpath = '//*[@id="mw-content-text"]/table[4]') %>%
  html_table()
table = table[[1]]
names(table)[3] = paste("State")

table$Change = str_extract(table$Change, "(\\+|\\−)\\d+\\.\\d+\\%")
table$City = str_replace(table$City, "\\[\\d+\\]", "")
table$`2014 land area` = str_replace(table$`2014 land area`, "\\d+\\♠", "")
table$`2010 population density` = str_replace(table$`2010 population density`, "\\d+\\♠", "")
table$latitude = as.numeric(str_extract(location, "\\d+\\.\\d+"))
table$longitude = as.numeric(str_extract(location, "\\-\\d+\\.\\d+"))
table$`2010 Census` = as.numeric(str_replace_all(table$`2010 Census`, ",", ""))
table$`2015 estimate` = as.numeric(str_replace_all(table$`2015 estimate`, ",", ""))

# Create your location data frame here
us_locs = table %>% 
  select(-Location) %>%
  filter(`2010 Census` > 500000)
```


<br/>
 
#### Task 3 - Shiny Predictions (40 pts)

Your third task is to create a shiny app to provide a GUI interface for the `get_darksky` function we wrote earlier.
This app should allow the user to select a city from a list and provide a visualization of the hourly weather forecast for that location. 

Your app should have the following features:

* Your visualization should always include the temperature, but also allow the user to select a second quantity (e.g. precipitation chance, barometric pressure, etc.) to optionally display on the *same* plot - this must also include appropriate axes and legend.

* The list of cities should come from the data frame your created in Task 2.

* When a city is selected its latitude and longitude should also be reported in the user interface. 

* UI should also allow the user to specify a historical date for the forecast

* Extra credit for adding bells and whistles and overall polish / design of your app.


<hr/>

<!-- Include your write up here and or below -->

```{r echo=FALSE}
# Modify this default shiny app

shinyApp(
  ui = fluidPage(
     titlePanel("Hourly Weather Forecast"),
       # sidebarPanel(
       #   sliderInput("bins", "Number of bins:",  min = 1, max = 50, value = 30)
       # ),
        # mainPanel(
        #   h4("results"),
        #    plotOutput("distPlot"),
        #    tableOutput("table1"),
        #    tableOutput("table2")
        # ),
         selectInput(inputId = "city", 
                      label = "Please choose the city",
                      choices = us_locs$City),
         hr(),
         selectInput(inputId = "second",
                     label = "Please select second quantity",
                     choices = c("precipIntensity", "precipProbability", "apparentTemperature", "dewPoint", "humidity", "windSpeed", "windBearing", "visibility","cloudCover","pressure"),
                     selected = "humidity"
                     ),
         h4("Historical Date"),
         dateInput(inputId = "date",
                 label = "Please specify the date:",
                 value = "2016-11-03",
                 format = "yyyy-mm-dd"
       ),
        hr(),
        textInput(inputId = "key", 
                  label = "key", 
                  value = "3fb318b0ba046bde99d853585774584e"),
      # sidebarLayout(
      #  sidebarPanel(
      #    sliderInput("bins", "Number of bins:",  min = 1, max = 50, value = 30)
      #  ),
        mainPanel(
          h4("results"),
           plotOutput("distPlot"),
           tableOutput("table1"),
           plotOutput("plot1")
        )
      #)
  ),
  server = function(input, output, session) 
  {   
    key = reactive({input$key})
    location = reactive({
      geocode(input$city)
    })
    lat = reactive({location()[[2]]})
    long = reactive({location()[[1]]})
    date = reactive({input$date})
    
    result = reactive({
      get_darksky(key = key(),
                  lat = lat(),
                  long = long(),
                  date = date())
    })
    
    second = reactive({input$second})
    
     output$table1 = renderTable({
        aa1 = lat()
        bb1 = long()
        data.frame("latitude" = aa1, "longitude" = bb1)
     })
     output$distPlot = renderPlot({
       plot(result()$temperature, type = "l", xlab = "Time", ylab = "Temperature")
     })
    
     output$plot1 = renderPlot({
         if(length(second()) >0){
          plot(result()[,second()],type = "l", xlab = "Time", ylab = "second feature")
        }
     })
  }
)
```